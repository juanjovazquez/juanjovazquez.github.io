<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title>Juanjo Vázquez</title>
	<subtitle>Personal site</subtitle>
	
	<link href="https://www.juanjovazquez.es/feed/feed.xml" rel="self"/>
	<link href="https://www.juanjovazquez.es"/>
	<updated>2021-06-13T00:00:00Z</updated>
	<id>https://juanjovazquez.es/</id>
	<author>
		<name>Juanjo Vázquez</name>
		<email>juanjo.vazquez@gmail.com</email>
	</author>
	
	<entry>
		<title>Reflexiones sobre Scala</title>
		<link href="https://www.juanjovazquez.es/posts/reflexiones_sobre_scala/"/>
		<updated>2021-06-13T00:00:00Z</updated>
		<id>https://www.juanjovazquez.es/posts/reflexiones_sobre_scala/</id>
		<content type="html">&lt;p&gt;Llevo programando y pensando en &lt;a href=&quot;https://en.wikipedia.org/wiki/Scala_(programming_language)&quot;&gt;Scala&lt;/a&gt; desde 2013. El lenguaje se publicó por primera vez en 2004 por lo que desde ese punto de vista no se me podría considerar un early adopter. Sin embargo, desde la perspectiva del software empresarial sí que puede admitirse que lo cogimos pronto cuando &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_(programming_language)&quot;&gt;Java&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Sun_acquisition_by_Oracle&quot;&gt;ya en manos de Oracle&lt;/a&gt;, mostraba claros &lt;a href=&quot;https://twitter.com/InfoWorld/status/497371542754717696&quot;&gt;signos de estancamiento&lt;/a&gt; y falta de innovación.&lt;/p&gt;
&lt;p&gt;La decisión no fue improvisada ni mucho menos. Hablé con bastante gente, incluido algunos analistas de &lt;a href=&quot;https://en.wikipedia.org/wiki/Gartner&quot;&gt;Gartner&lt;/a&gt;, lo cual no garantiza nada pero ayuda a justificar las inversiones en tecnología, qué le vamos a hacer. En aquellas charlas, llegué a referirme a este camino por el que estaba discurriendo Java como &lt;em&gt;cobolización&lt;/em&gt; (curiosamente el término gustó y fue usado en público por uno de estos analistas).&lt;/p&gt;
&lt;p&gt;Por aquel entonces se me encargó la misión de construir una plataforma cloud nativa para el sector de la energía que fuera capaz de escalar, trabajar concurrentemente con &lt;em&gt;mucha data&lt;/em&gt;, global, innovadora y todos los requerimientos técnicos que os podáis imaginar. El &lt;em&gt;hype&lt;/em&gt; alrededor del Cloud y el Big Data era abrumador. El ecosistema Java está ahora muy bien servido en ese área con proyectos como &lt;a href=&quot;https://spring.io/projects/spring-boot&quot;&gt;Spring Boot&lt;/a&gt;, &lt;a href=&quot;https://micronaut.io/&quot;&gt;Micronaut&lt;/a&gt; o &lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus&lt;/a&gt;, pero entonces no había muchas opciones atractivas en la &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_virtual_machine&quot;&gt;JVM&lt;/a&gt; para hacer lo que luego se llamó &lt;a href=&quot;https://en.wikipedia.org/wiki/Microservices&quot;&gt;microservicios&lt;/a&gt;, excepto &lt;a href=&quot;https://akka.io/&quot;&gt;Akka&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;No queríamos abandonar la JVM y de hecho Akka ofrecía también un API para Java pero el proyecto tenía un bias claro hacia Scala, el lenguaje con el que se había escrito. Algunos gigantes de Internet estaban ya usando y promoviendo Scala como LinkedIn, Twitter o Foursquare, probablemente al principio como un mejor Java. No estábamos solos. ¿Por qué no podíamos hacerlo nosotros?.&lt;/p&gt;
&lt;h2 id=&quot;dificultades-y-lecciones&quot;&gt;Dificultades y lecciones &lt;a class=&quot;direct-link&quot; href=&quot;https://www.juanjovazquez.es/posts/reflexiones_sobre_scala/#dificultades-y-lecciones&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;No fue fácil, para qué nos vamos a engañar. Scala tiene fama de ser un &lt;a href=&quot;https://www.reddit.com/r/scala/comments/kjcwgf/why_is_scala_considered_hard/&quot;&gt;lenguaje complejo&lt;/a&gt; y, en fin, lo es. Los que opinan que no es más complejo que otros, digamos &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;, aducen que la dificultad no proviene del lenguaje en sí sino del cambio de &lt;a href=&quot;https://en.wikipedia.org/wiki/Programming_paradigm&quot;&gt;paradigma&lt;/a&gt; que supone pasar de la mentalidad &lt;a href=&quot;https://en.wikipedia.org/wiki/Imperative_programming&quot;&gt;imperativa&lt;/a&gt; y &lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;orientada a objetos&lt;/a&gt; a la &lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;programación funcional&lt;/a&gt; y &lt;a href=&quot;https://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarativa&lt;/a&gt;. No estoy de acuerdo. La dificultad proviene de la absoluta ausencia de &lt;a href=&quot;https://stackoverflow.com/questions/802050/what-is-opinionated-software&quot;&gt;dogmatismo&lt;/a&gt; que se traduce en mil maneras distintas de hacer las cosas.&lt;/p&gt;
&lt;p&gt;En su momento traté de corroborar esta tesis con un par de experimentos. En el primero de ellos recurrí a la fuente y me propuse aprender el lenguaje funcional puro y sin mácula por excelencia: &lt;a href=&quot;https://en.wikipedia.org/wiki/Haskell_(programming_language)&quot;&gt;Haskell&lt;/a&gt;. Dejando a un lado la jerga de la &lt;a href=&quot;https://en.wikipedia.org/wiki/Category_theory&quot;&gt;teoría de categorías&lt;/a&gt;, que bueno, se las trae pero te acostumbras una vez aprendes a introducir letras griegas desde el teclado, me pareció mucho más accesible y simple. Y lo es porque todo el lenguaje pivota en torno a premisas incontestables, dogmas que toda la comunidad de Haskell sigue con verdadera devoción. &lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;Inmutabilidad&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Referential_transparency&quot;&gt;transparencia referencial&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_class&quot;&gt;type classes&lt;/a&gt;, no &lt;a href=&quot;https://en.wikipedia.org/wiki/Subtyping&quot;&gt;subtipado&lt;/a&gt;, declaratividad, brevedad, &lt;a href=&quot;https://en.wikipedia.org/wiki/Monad_(functional_programming)&quot;&gt;monads&lt;/a&gt;, etc. Cada libro, cada ejemplo, cada artículo refuerza una y otra vez estas verdades absolutas que no se cuestionan generando un ecosistema unificado cuyo único peligro es caer en la autocomplacencia.&lt;/p&gt;
&lt;p&gt;Para el segundo experimento me propuse desarrollar una aplicación en Python pero abandonando de forma deliberada los &lt;a href=&quot;https://www.python.org/dev/peps/pep-0020/&quot;&gt;dogmas del pythonismo&lt;/a&gt;. Traté de no usar variables mutables, nada de bucles, muchos &lt;a href=&quot;https://www.python.org/dev/peps/pep-0255/&quot;&gt;generators&lt;/a&gt;, &lt;a href=&quot;https://www.python.org/dev/peps/pep-0557/&quot;&gt;data classes&lt;/a&gt;, &lt;a href=&quot;http://reactivex.io/&quot;&gt;diseño reactivo&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambdas&lt;/a&gt;, etc. En esta prueba descubrí dos cosas importantes. La primera es que echaba mucho de menos el &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_system&quot;&gt;tipado estático&lt;/a&gt; de Haskell y Scala. La segunda es que Python es un lenguaje muy rico en características con el que se puede hacer programación funcional pero, al contrario que lo que ocurrió con Haskell, todo el ecosistema te empujaba a aplicar exactamente la mentalidad opuesta, es decir, mutabilidad, &lt;a href=&quot;https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)&quot;&gt;herencia&lt;/a&gt;, verbosidad, etc. La respuesta habitual solía ser, ¿por qué lo quieres hacer de otra manera?, ¿por qué te complicas la vida?. Aquí no lo hacemos así.&lt;/p&gt;
&lt;h2 id=&quot;guerras-de-fe&quot;&gt;Guerras de fe &lt;a class=&quot;direct-link&quot; href=&quot;https://www.juanjovazquez.es/posts/reflexiones_sobre_scala/#guerras-de-fe&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Es evidente que la programación moderna está cada vez más guiada por sus usuarios, y cada vez menos por sus creadores, sean comités, empresas o &lt;a href=&quot;https://en.wikipedia.org/wiki/Benevolent_dictatorship&quot;&gt;dictadores benevolentes&lt;/a&gt;. La evolución de los lenguajes es permeable al medio y se nutre continuamente de su ecosistema que se manifiesta en forma de librerías &lt;em&gt;open source&lt;/em&gt;, artículos, entradas en Stack Overflow o Reddit, conferencias, tutoriales, etc. Ya muy pocos se adentran en un nuevo lenguaje con el libro, si lo hay, y la especificación, si la hay, bajo el brazo. Uno se hace un &lt;a href=&quot;https://en.wikipedia.org/wiki/Massive_open_online_course&quot;&gt;MOOC&lt;/a&gt; en Coursera, estudia unos cuantos tutoriales y a programar se ha dicho. Ya iremos solucionando los problemas tal y como vayan llegando.&lt;/p&gt;
&lt;p&gt;En un contexto así, los dogmas se materializan en &lt;a href=&quot;https://en.wikipedia.org/wiki/Programming_idiom&quot;&gt;estructuras idiomáticas&lt;/a&gt; que ayudan a mantener la simplicidad, la unidad y la homogeneidad. El código resultará más legible porque encuentras los mismos principios aplicados una y otra vez. Sencillamente, el código resulta familiar y eso se traduce en ahorro de horas en la actividad más habitual del programador: mantener el código de otros o el de tu yo del pasado. Sí, ése que siempre es peor que el de tu yo de ahora. Pero, ¿qué pasa cuando las opciones son virtualmente ilimitadas?.&lt;/p&gt;
&lt;p&gt;Cuando no hay dogmas, resulta que los individuos se los crean organizándose en subcomunidades o tribus. Echad un vistazo a &lt;a href=&quot;https://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; y sus incontables &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_framework&quot;&gt;frameworks&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Angular_(web_framework)&quot;&gt;Angular&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/React_(JavaScript_library)&quot;&gt;React&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Vue.js&quot;&gt;Vue.js&lt;/a&gt;, etc, cada uno de ellos configurando sus propias comunidades, con sus principios y cultura propias. JavaScript, que nació siendo un modesto lenguaje para dotar de algo de interactividad a las torpes webs de los noventa, se ha convertido en una especie de &lt;em&gt;lingua franca&lt;/em&gt; del desarrollo &lt;em&gt;front&lt;/em&gt; estirándose como un chicle y reinventándose a sí mismo una y otra vez mientras defiende su reinado frente a sus nuevos competidores, como &lt;a href=&quot;https://en.wikipedia.org/wiki/TypeScript&quot;&gt;TypeScript&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Elm_(programming_language)&quot;&gt;Elm&lt;/a&gt; o &lt;a href=&quot;https://en.wikipedia.org/wiki/Dart_(programming_language)&quot;&gt;Dart&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Scala, más académico y formal, enraizado en el mundo de la &lt;a href=&quot;https://www.epfl.ch/labs/lamp/&quot;&gt;investigación&lt;/a&gt; y empujado por &lt;em&gt;postdocs&lt;/em&gt; cuya máxima aspiración era que el resultado de sus tesis acabara en master, presenta sin embargo síntomas similares. Plantearse el diseño de un lenguaje desde la óptica de hibridar la orientación a objetos y la programación funcional, es cuanto menos ambicioso y muy osado, teniendo en cuenta que ya existen comunidades bien establecidas en ambos lados que estarán dispuestas a defender ardorosamente sus postulados y que se reconocerán como antagonistas. A priori, la &lt;a href=&quot;https://www.scala-lang.org/blog/2019/05/02/community.html&quot;&gt;convivencia&lt;/a&gt; en esta suerte de franja de Gaza parece complicada. Y efectivamente eso es lo que hemos visto.&lt;/p&gt;
&lt;p&gt;Las guerras de fe entre distintas tribus han sido continuas en &lt;em&gt;Scalaland&lt;/em&gt; llegando incluso a &lt;a href=&quot;https://typelevel.org/blog/2019/09/05/jdg.html&quot;&gt;personificarse&lt;/a&gt;. Por un lado, la &lt;a href=&quot;https://www.epfl.ch/labs/lamp/&quot;&gt;EPFL&lt;/a&gt; defendiendo su proposición de valor que resulta de la combinación de objetos, programación funcional e interoperabilidad con Java. Por otro, los haskellers que encontraron una oportunidad de monetizar sus inversiones intelectuales con un lenguaje que, dándole algunos martillazos, permitía programar &lt;em&gt;à la&lt;/em&gt; Haskell y que te pagaran por ello. En medio, los programadores rasos no radicalizados que en sus contextos corporativos sólo querían hacer el trabajo y se apoyaban en &lt;a href=&quot;https://akka.io/&quot;&gt;Akka&lt;/a&gt; y &lt;a href=&quot;https://spark.apache.org/&quot;&gt;Spark&lt;/a&gt; principalmente.&lt;/p&gt;
&lt;h2 id=&quot;liderazgo-y-gobierno&quot;&gt;Liderazgo y gobierno &lt;a class=&quot;direct-link&quot; href=&quot;https://www.juanjovazquez.es/posts/reflexiones_sobre_scala/#liderazgo-y-gobierno&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;No he conocido ninguna comunidad de programación que cuestione tanto su liderazgo como la Scala community. Es cierto que incluso &lt;a href=&quot;https://en.wikipedia.org/wiki/Guido_van_Rossum&quot;&gt;Guido&lt;/a&gt; ha terminado por &lt;a href=&quot;https://www.mail-archive.com/python-committers@python.org/msg05628.html&quot;&gt;tirar la toalla&lt;/a&gt; cansado de tener que aguantar &lt;em&gt;carros y carretas&lt;/em&gt; por defender sus postulados, pero lo que ha tenido que soportar &lt;a href=&quot;https://en.wikipedia.org/wiki/Martin_Odersky&quot;&gt;Odersky&lt;/a&gt; todos estos años ha estado a la altura de &lt;a href=&quot;https://en.wikipedia.org/wiki/Simon_of_the_Desert&quot;&gt;Simón del desierto&lt;/a&gt;. Como colofón, recientemente tuvo que enfrentar la &lt;a href=&quot;https://en.wikipedia.org/wiki/Cancel_culture&quot;&gt;cancelación&lt;/a&gt; de uno de los miembros más valorados de la comunidad por supuestas &lt;a href=&quot;https://scala-open-letter.github.io/&quot;&gt;conductas inapropiadas&lt;/a&gt; en su ámbito privado, todo ello a una semana del anuncio de la primera release de &lt;a href=&quot;https://www.scala-lang.org/blog/2021/05/14/scala3-is-here.html&quot;&gt;Scala 3&lt;/a&gt; con el consiguiente eclipse informativo. Un nuevo compilador en el que ha &lt;a href=&quot;https://github.com/lampepfl/dotty/graphs/contributors&quot;&gt;invertido ocho años de su vida&lt;/a&gt; y la de su equipo. De traca.&lt;/p&gt;
&lt;p&gt;Por supuesto con esto no quiero decir que no se pueda discrepar del dictador benevolente, sobre todo cuando existen los mecanismos para ello, como &lt;a href=&quot;https://www.scala-lang.org/community/&quot;&gt;foros de discusión y grupos de trabajo&lt;/a&gt;, pero creo que también es justo respetar que alguien quiera llevar a cabo su plan y materializar sus ideas apoyándose en personas y organizaciones afines. Pero efectivamente, en estos tiempos de lo políticamente correcto, parece cada vez más difícil construir algo con independencia y criterios puramente técnicos. Quizá por ello lenguajes más jóvenes están optando por modelos de gobierno más abiertos como el caso de &lt;a href=&quot;https://en.wikipedia.org/wiki/Rust_(programming_language)&quot;&gt;Rust&lt;/a&gt; o &lt;a href=&quot;https://www.unisonweb.org/&quot;&gt;Unison&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;scala-ahora&quot;&gt;Scala ahora &lt;a class=&quot;direct-link&quot; href=&quot;https://www.juanjovazquez.es/posts/reflexiones_sobre_scala/#scala-ahora&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Con todo, Scala me ha devuelto con creces todo lo que he invertido en él y lo recomendaría como la mejor manera de hacer back-end generalista ahora. Una vez has encontrado tu manera de expresarte con el lenguaje, las abstracciones e &lt;em&gt;idioms&lt;/em&gt; adecuados para tu dominio, y construido un equipo que comparte objetivos y formas de hacer, no hay vuelta atrás.&lt;/p&gt;
&lt;p&gt;Resulta refrescante poder empezar un proyecto con su método &lt;em&gt;main&lt;/em&gt; y tirar adelante con &lt;em&gt;vanilla&lt;/em&gt; Scala sin pensar en &lt;em&gt;frameworks&lt;/em&gt; ni recetas. Por supuesto seguro que necesitas librerías, pero las vas añadiendo poco a poco sin que condicionen excesivamente tu estilo de programación, sólo como utilidades. Las ideas que incorporas de la programación funcional y declarativa te guiarán hacia un código más libre de &lt;em&gt;bugs&lt;/em&gt;, más fácilmente testeable, muchas veces sin necesidad de &lt;em&gt;mocks&lt;/em&gt;. Si la mayor parte de tu código está libre de &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_(computer_science)&quot;&gt;side effects&lt;/a&gt;&lt;/em&gt; es testeable tal cual, es &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_compositionality&quot;&gt;composicional&lt;/a&gt; y podrás hacer &lt;em&gt;lego programming&lt;/em&gt;, construyendo estructuras complejas a partir de las otras más simples. Vivirás esos momentos de gratificación extrema cuando, tras programar durante varias horas y compilar, tu código funciona a la primera. Si compila funciona, ¿verdad?.&lt;/p&gt;
&lt;p&gt;Scala no es perfecto, pero es uno de los pocos lenguajes que ha llevado el concepto de declaratividad al programador medio que trabaja en problemas reales del día a día. Bien orientados, tus programas se acercan mucho más a descripciones de la lógica de negocio que tratan de resolver y menos a los detalles de infraestructura y ejecución. Hablamos de programación de alto nivel claro está. ¡No lo uses para escribir &lt;em&gt;drivers&lt;/em&gt; de Linux!.&lt;/p&gt;
&lt;p&gt;No te quiero engañar. Si vienes de la programación imperativa y orientada a objetos te va a costar. Tendrás que aprender muchas cosas nuevas y pasará algo de tiempo hasta que encuentres tu propia voz  pero el viaje merecerá la pena. Empezarás a pensar en la programación de otra manera, más desde los fundamentos y menos desde las herramientas que han construido otros. Te convertirás en un programador activo y creativo que cuestiona sus propias decisiones y busca la mejora continua del código. No querrás volver a lo de antes. No querrás volver a tener que leer cientos de líneas para entender lo que hace un función y dónde demonios se actualiza la variable que te está generando ese &lt;em&gt;bug&lt;/em&gt; en producción.&lt;/p&gt;
&lt;p&gt;Scala 3 culmina un ciclo marcado por la innovación y sienta las bases para un progreso más estable centrado en la compatibilidad y el mantenimiento de las inversiones, tanto en conocimiento como en la base de código. Con la incorporación del nuevo framework de &lt;a href=&quot;https://en.wikipedia.org/wiki/Metaprogramming&quot;&gt;metaprogramación&lt;/a&gt;, basado en &lt;em&gt;&lt;a href=&quot;https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html&quot;&gt;quotations&lt;/a&gt;&lt;/em&gt;, se termina en mi opinión de establecer los puentes entre la tradición de &lt;a href=&quot;https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html&quot;&gt;Lisp&lt;/a&gt; y la orientación de objetos, uniendo la academia con la industria.&lt;/p&gt;
&lt;p&gt;Es cierto que Java, y antes &lt;a href=&quot;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&quot;&gt;C#&lt;/a&gt; con &lt;a href=&quot;https://en.wikipedia.org/wiki/Language_Integrated_Query&quot;&gt;LINQ&lt;/a&gt;, están adaptándose progresivamente hacia un modelo de programación más declarativo. Una programación más del &lt;em&gt;qué&lt;/em&gt;,  que del &lt;em&gt;cómo&lt;/em&gt;. Pero Scala parece estar siempre un paso por delante, atrayendo a usuarios y organizaciones que quieren estar en la cresta de la ola y no tener que esperar años para poder &lt;a href=&quot;https://dotty.epfl.ch/blog/2021/06/07/scala3.0.1-rc1-release.html#experimental-language-features-policy&quot;&gt;experimentar&lt;/a&gt; con características que les hagan más competitivos.&lt;/p&gt;
&lt;p&gt;El &lt;em&gt;hype&lt;/em&gt; sobre Scala &lt;a href=&quot;https://www.lihaoyi.com/post/TheDeathofHypeWhatsNextforScala.html&quot;&gt;ha pasado&lt;/a&gt; y probablemente su &lt;em&gt;legacy&lt;/em&gt; no le permita innovar tanto como los lenguajes que vienen desde el futuro. Pero tras mejorar en herramientas, construir un &lt;a href=&quot;https://index.scala-lang.org/&quot;&gt;ecosistema de librerías&lt;/a&gt; rico, propias y heredadas de Java, y conseguir la &lt;a href=&quot;https://docs.scala-lang.org/overviews/core/binary-compatibility-for-library-authors.html&quot;&gt;compatibilidad binaria&lt;/a&gt;, Scala está preparado para el &lt;em&gt;mainstream&lt;/em&gt;. El momento es ahora.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>El modelo relacional</title>
		<link href="https://www.juanjovazquez.es/posts/el_modelo_relacional/"/>
		<updated>2021-06-06T00:00:00Z</updated>
		<id>https://www.juanjovazquez.es/posts/el_modelo_relacional/</id>
		<content type="html">&lt;p&gt;&amp;quot;Pásame por favor el modelo de datos&amp;quot;, ¿os suena familiar?. Si la respuesta es que sí, seguro que como yo has ido a un montón de reuniones técnicas para hablar de cómo demonios integrarse con tu sistema. El modelo de datos, el santo grial que conduce a la verdad absoluta sobre un sistema de software. Pero, ¿realmente lo es?. Sinceramente lo dudo y creo que responde más al deseo de quien pregunta de asumir algo que pueda comprender, que encaje en su modelo mental y pueda mantener sin tener que aprender nada nuevo que cuestione sus mantras y verdades absolutas.&lt;/p&gt;
&lt;p&gt;Para empezar, ¿sobre qué modelo y sobre qué datos se nos pregunta?. Aunque no se especifique claramente, todos sabemos de qué estamos hablando: un &lt;a href=&quot;https://en.wikipedia.org/wiki/Relational_model&quot;&gt;modelo de datos relacional&lt;/a&gt; y operacional en &lt;a href=&quot;https://en.wikipedia.org/wiki/Database_normalization&quot;&gt;tercera forma normal&lt;/a&gt;. Es decir, la típica sábana de tablas con relaciones que modelan entidades y (supuestamente) procesos de negocio. Hasta te puedes imaginar la arquitectura de la aplicación que trabaja con estos datos. Tres capas, con su front y back, &lt;a href=&quot;https://en.wikipedia.org/wiki/Create,_read,_update_and_delete&quot;&gt;CRUD&lt;/a&gt; por supuesto, algún framework que lo pegue todo, en Python, C#, Java o PHP, qué más da. Se parecen todas. El código es irrelevante porque todo lo importante está en la base de datos, ¿verdad?.&lt;/p&gt;
&lt;p&gt;La hipérbole de esta manera de pensar fueron los procesos almacenados. Los señores &lt;a href=&quot;https://en.wikipedia.org/wiki/Larry_Ellison&quot;&gt;Ellison&lt;/a&gt; y &lt;a href=&quot;https://en.wikipedia.org/wiki/Bill_Gates&quot;&gt;Gates&lt;/a&gt; nos ataron a sus &lt;a href=&quot;https://en.wikipedia.org/wiki/Oracle_Database&quot;&gt;Oracle&lt;/a&gt; y &lt;a href=&quot;https://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; generando toneladas de código propietario del que todavía muchos están tratando de salir. La lógica de negocio quedaba relegada a una fina capa de código que invocaba a un &lt;a href=&quot;https://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;procedimiento almacenado&lt;/a&gt; que se ocupaba del resto. Resto, que a la postre era lo que realmente importaba. Procedimientos que no componen por supuesto. Y cuando algo no iba bien, ponte a debuguear. Por cierto, la historia del &lt;em&gt;vendor lock-in&lt;/em&gt; se sigue repitiendo disfrazada de novedad tecnológica (hola &lt;a href=&quot;https://en.wikipedia.org/wiki/AWS_Lambda&quot;&gt;Amazon Lambda&lt;/a&gt;). No caigais en la trampa de nuevo. Las consultoras harán el agosto y después te tocará a ti lidiar con el legacy. Mal negocio.&lt;/p&gt;
&lt;p&gt;Pues resulta que cuando quieres escalar una aplicación entonces la base de datos, &lt;em&gt;esa&lt;/em&gt; base de datos, se convierte en un problema. Para empezar, la escalabilidad horizontal pondrá tus queridas propiedades &lt;a href=&quot;https://en.wikipedia.org/wiki/ACID&quot;&gt;ACID&lt;/a&gt;, ésas que hacen posible que tu lógica de negocio esté enterrada entre las tablas de la base de datos, contra las cuerdas. Tendrás que aprender un nuevo acrónimo, &lt;a href=&quot;https://en.wikipedia.org/wiki/CAP_theorem&quot;&gt;CAP&lt;/a&gt;, y entender por qué te afecta y por qué tu mundo ideal en el que el código importa más bien poco se derrumba. Ponte a reaprender a programar, a replantearte muchas cosas que hacías y, para bien, a descubrir todo lo que te estabas perdiendo. Por supuesto siempre puedes escalar verticalmente pero entonces prepara la cartera, de nuevo Ellison &lt;em&gt;et al.&lt;/em&gt; se pondrán muy contentos.&lt;/p&gt;
&lt;p&gt;Por supuesto empiezan a aparecer alternativas que podrían permitirte volver a la comodidad de las garantías ACID y el modelo relacional en el mundo operacional, como &lt;a href=&quot;https://en.wikipedia.org/wiki/Spanner_(database)&quot;&gt;Google Spanner&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/CockroachDB&quot;&gt;CockroachDB&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/FoundationDB&quot;&gt;FoundationDB&lt;/a&gt;, &lt;a href=&quot;https://fauna.com/&quot;&gt;FaunaDB&lt;/a&gt;, etc, algunas de ellas inspiradas en el &lt;em&gt;&lt;a href=&quot;https://blog.acolyer.org/2019/03/29/calvin-fast-distributed-transactions-for-partitioned-database-systems/&quot;&gt;Calvin paper&lt;/a&gt;&lt;/em&gt;, y que explotan diversos compromisos a los que puede llegarse para superar las limitaciones que impone CAP. Mientras esto madura, el tiempo de las &lt;a href=&quot;https://en.wikipedia.org/wiki/Apache_Cassandra&quot;&gt;Cassandras&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/MongoDB&quot;&gt;Mongos&lt;/a&gt; y &lt;a href=&quot;https://en.wikipedia.org/wiki/Amazon_DynamoDB&quot;&gt;Dynamos&lt;/a&gt; continúa, lo que conocemos por &lt;a href=&quot;https://en.wikipedia.org/wiki/NoSQL&quot;&gt;NoSQL&lt;/a&gt;. Vamos hacia una convivencia entre ambas aproximaciones, como siempre, dependiendo de tu caso de uso. Qué esperabas. No iba a ser tan fácil, ¿no?.&lt;/p&gt;
&lt;h2 id=&quot;vuelta-a-los-lenguajes-de-programaci%C3%B3n&quot;&gt;Vuelta a los lenguajes de programación &lt;a class=&quot;direct-link&quot; href=&quot;https://www.juanjovazquez.es/posts/el_modelo_relacional/#vuelta-a-los-lenguajes-de-programaci%C3%B3n&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;En cualquier caso, si algo hemos aprendido por el camino es que es el momento de los lenguajes de programación. La base de datos debe ser tu capa de persistencia, nada más, ni nada menos. La lógica de negocio, lo importante, se merece la mejor herramienta que tengas para expresar sus intrincadas reglas y dependencias. Un lenguaje de programación de alto nivel y un paradigma que te permitan componer programas como piezas simples que encajan para componer otras más complejas. En mi caso, en los últimos años estas herramientas han sido &lt;a href=&quot;https://en.wikipedia.org/wiki/Scala_(programming_language)&quot;&gt;Scala&lt;/a&gt; y la &lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;programación funcional&lt;/a&gt;, pero pueden ser otras. Lo importante es no renunciar a un montón de años de investigación sobre computabilidad y lenguajes, desde &lt;a href=&quot;https://en.wikipedia.org/wiki/Ada_Lovelace&quot;&gt;Ada Lovelace&lt;/a&gt; a &lt;a href=&quot;https://en.wikipedia.org/wiki/Martin_Odersky&quot;&gt;Martin Odersky&lt;/a&gt; o &lt;a href=&quot;https://en.wikipedia.org/wiki/Philip_Wadler&quot;&gt;Philip Wadler&lt;/a&gt;, y aprovechar la mejor herramienta a tu alcance para expresarte. El mundo no se acaba en el SQL y en Excel, lo podemos hacer mucho mejor.&lt;/p&gt;
&lt;p&gt;¿Significa esto que debería renunciar a mi modesta pero robusta PostgreSQL?. Para nada. Si cubre tus necesidades de persistencia probablemente no haya nada mejor. Pero si el problema técnico a resolver requiere de otra cosa, tampoco le des martillazos a la pobre &lt;a href=&quot;https://en.wikipedia.org/wiki/PostgreSQL&quot;&gt;PostgreSQL&lt;/a&gt; para que se parezca a lo que necesitas. Probablemente te toque remangarte y ponerte a diseñar pensando no sólo en los requerimientos funcionales sino también en los técnicos. Cuando eso ocurra, probablemente lo último que debes pensar es en qué base de datos y aproximación de persistencia vas a tomar. Piensa primero en cómo vas a resolver el problema con tu lenguaje de programación o incluso plantéate si es el adecuado para el problema a resolver, aunque no menosprecies el coste del cambio. Todo cuesta.&lt;/p&gt;
&lt;p&gt;Últimamente cuando me piden el modelo de datos suelo responder que mi sistema tiene unos cuantos, ¿a cuál te refieres?, ¿seguridad?, ¿algún servicio de negocio concreto?. Si tienes tiempo te explico el diseño del sistema. Es muy interesante ya verás. Y en una pizarra, física o virtual, se va explicando. Con todas sus complejidades y matices. Lo siento pero no me cabe en un Excel y mucho menos en un PowerPoint. Esto no es fácil, ya sabes.&lt;/p&gt;
</content>
	</entry>
</feed>
